/*
 * Copyright © 2014 René Bernhardsgrütter, Christoph Walter Senn at Zurich
 * University of Applied Sciences; 2014 Helmut Hauser at University of Zurich
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the “Software”), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package ch.zhaw.iamp.rct.graph;

import java.util.Collections;
import java.util.List;

/**
 * A {@link GraphConverter} allows to convert {@link NetworkGraph}s to
 * {@code csv} files (masses and connection map) and vice-versa.
 *
 * @see NetworkGraph
 */
public class GraphConverter {

    final static String MASSES_PREAMBLE = "# This file was generated by the graphical user interface.\n\n# Masses:\n\n";
    final static String CONNECTION_MAP_PREAMBLE = "# This file was generated by the graphical user interface.\n\n# Masses and connection type:\n\n";
    final static String Z_AXIS_VALUE = "0";
    final static String SEPARATOR = ",";
    final static String NEWLINE = "\n";

    /**
     * Converts the masses of the given {@link NetworkGraph} to a comma
     * separated String.
     *
     * @param graph A graph to convert.
     * @return The comma separated String.
     * @throws IllegalArgumentException If the argument is null.
     */
    public static String toMassesCsv(NetworkGraph graph) {
        if (graph == null) {
            throw new IllegalArgumentException("The argument may not be null.");
        }

        String output = MASSES_PREAMBLE;

        for (int i = 0; i < graph.getMasses().size(); i++) {
            Mass currentMass = graph.getMasses().get(i);

            output += currentMass.getType().getCsvValue();

            output += SEPARATOR + currentMass.x
                    + SEPARATOR + currentMass.y
                    + SEPARATOR + Z_AXIS_VALUE
                    + getConnectionsToPriorMasses(currentMass, graph);

            output += NEWLINE;
        }

        return output;
    }

    static String getConnectionsToPriorMasses(Mass currentMass, NetworkGraph graph) {
        String output = "";

        for (int i = 0; i < currentMass.getIndex(graph); i++) {
            Mass candidate = graph.getMasses().get(i);

            for (Spring spring : graph.getSprings(candidate)) {
                if (spring.isConnected(currentMass)) {
                    output += SEPARATOR + i;
                }
            }
        }

        return output;
    }

    /**
     * Converts the {@link Spring} connections of the given {@link NetworkGraph}
     * to a comma separated String.
     * <p>
     * The order has its complexity. A valid example would be:<br />
     * 3,0,1<br />
     * 4,1,5<br />
     * 4,2,1<br />
     * <p>
     * An invalid example would be:<br />
     * 4,1,5<br />
     * 3,0,1 // index 3 is smaller than index 4, so it has to come before index
     * 4 <br />
     * 6,2,1<br />
     * <p>
     * Another invalid example would be:<br />
     * 1,2,5 // index 2 is higher than index 1, so it has to come fist on this
     * line<br />
     * 4,0,1<br />
     * 6,2,1<br />
     *
     * @param graph A graph to convert.
     * @return The comma separated String.
     * @throws IllegalArgumentException If the argument is null.
     */
    public static String toConnectionMapCsv(NetworkGraph graph) {
        if (graph == null) {
            throw new IllegalArgumentException("The argument may not be null.");
        }

        String output = CONNECTION_MAP_PREAMBLE;

        List<Spring> springs = graph.getSprings();
        Collections.sort(springs);

        for (Spring spring : springs) {
            Mass firstColumn = spring.getMassWithHigherIndex();
            Mass secondColumn = spring.getMassWithLowerIndex();

            output += firstColumn.getIndex(graph) + SEPARATOR
                    + secondColumn.getIndex(graph) + SEPARATOR
                    + spring.getConnectionType() + NEWLINE;
        }

        return output;
    }

    /**
     * Converts the given masses and connection map to a {@link NetworkGraph}.
     *
     * @param massesCsvContent The list of masses, represented as
     * comma-separated values (CSV) String.
     * @param connectionMapCsvContent The connection map, represented as
     * comma-separated values (CSV) String.
     * @return A new instance of {@link NetworkGraph}, containing the given
     * mass-spring network.
     */
    public static NetworkGraph toNetworkGraph(String massesCsvContent, String connectionMapCsvContent) {
        if (massesCsvContent == null || connectionMapCsvContent == null) {
            throw new IllegalArgumentException("The arguments may not be null.");
        }

        NetworkGraph graph = new NetworkGraph();

        for (String massLine : massesCsvContent.split(NEWLINE)) {
            massLine = massLine.trim();

            if (massLine.isEmpty() || massLine.startsWith("#")) {
                continue;
            }

            String[] lineParts = massLine.split(SEPARATOR);

            if (lineParts.length < 4) {
                System.out.println("Warning: A line of the masses file could not be parsed. It is being skipped.");
                continue;
            }

            Mass.Type type = Mass.Type.getByCsvValue(lineParts[0]);
            double xCoordinate = Double.valueOf(lineParts[1]);
            double yCoordinate = Double.valueOf(lineParts[2]);

            graph.addMasses(new Mass(xCoordinate, yCoordinate, type));
        }

        for (String connectionLine : connectionMapCsvContent.split(NEWLINE)) {
            connectionLine = connectionLine.trim();

            if (connectionLine.isEmpty() || connectionLine.startsWith("#")) {
                continue;
            }

            String[] lineParts = connectionLine.split(SEPARATOR);

            if (lineParts.length < 2) {
                System.out.println("Warning: A line of the connction map file could not be parsed. It is being skipped.");
                continue;
            }

            int sourceMassIndex = Integer.valueOf(lineParts[0]);
            int destinationMassIndex = Integer.valueOf(lineParts[1]);

            Mass sourceMass = graph.getMasses().get(sourceMassIndex);
            Mass destinationMass = graph.getMasses().get(destinationMassIndex);

            graph.addSpring(sourceMass, destinationMass);
        }

        return graph;
    }

}
